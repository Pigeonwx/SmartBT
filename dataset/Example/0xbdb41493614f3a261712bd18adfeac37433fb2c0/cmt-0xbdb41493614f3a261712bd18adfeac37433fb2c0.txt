{"contracts": [{"functions": [{"content": "function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public;", "token_seq": "function receiveApproval ( address _from , uint256 _value , address _token , bytes _extraData ) public ;", "context": ["tokenRecipient"], "lines": 1}], "function_num": 1, "valid_comment_num": 0}, {"functions": [{"content": "function matchcoin(\n        uint256 initialSupply,\n        string tokenName,\n        string tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n        balanceOf[msg.sender] = totalSupply;// Give the creator all initial tokens\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n    }", "token_seq": "function matchcoin ( uint256 initialSupply , string tokenName , string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256 ( decimals ) ; // Update total supply with the decimal amount balanceOf [ msg . sender ] = totalSupply ; // Give the creator all initial tokens name = tokenName ; // Set the name for display purposes symbol = tokenSymbol ; // Set the symbol for display purposes }", "context": ["matchcoin", "name", "symbol", "decimals", "totalSupply", "balanceOf", "allowance"], "lines": 10, "comment": {"raw": "/**\n     * Constructor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n     */", "parsed_comment": {"parse_first_step": "     * Constructor function     *     * Initializes contract with initial supply tokens to the creator of the contract     "}}}, {"content": "function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }", "token_seq": "function _transfer ( address _from , address _to , uint _value ) internal { // Prevent transfer to 0x0 address. Use burn() instead require ( _to != 0x0 ) ; // Check if the sender has enough require ( balanceOf [ _from ] >= _value ) ; // Check for overflows require ( balanceOf [ _to ] + _value > balanceOf [ _to ] ) ; // Save this for an assertion in the future uint previousBalances = balanceOf [ _from ] + balanceOf [ _to ] ; // Subtract from the sender balanceOf [ _from ] -= _value ; // Add the same to the recipient balanceOf [ _to ] += _value ; Transfer ( _from , _to , _value ) ; // Asserts are used to use static analysis to find bugs in your code. They should never fail assert ( balanceOf [ _from ] + balanceOf [ _to ] == previousBalances ) ; }", "context": ["matchcoin", "name", "symbol", "decimals", "totalSupply", "balanceOf", "allowance"], "lines": 17, "comment": {"raw": "/**\n     * Internal transfer, only can be called by this contract\n     */", "parsed_comment": {"parse_first_step": "     * Internal transfer, only can be called by this contract     "}}}, {"content": "function transfer(address _to, uint256 _value) public {\n        _transfer(msg.sender, _to, _value);\n    }", "token_seq": "function transfer ( address _to , uint256 _value ) public { _transfer ( msg . sender , _to , _value ) ; }", "context": ["matchcoin", "name", "symbol", "decimals", "totalSupply", "balanceOf", "allowance"], "lines": 3, "comment": {"raw": "/**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */", "parsed_comment": {"parse_first_step": "     * Transfer tokens     *     * Send `_value` tokens to `_to` from your account     *      @param _to The address of the recipient      @param _value the amount to send     ", "params": {"_to": "The address of the recipient", "_value": "the amount to send"}}}}, {"content": "function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }", "token_seq": "function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( _value <= allowance [ _from ] [ msg . sender ] ) ; // Check allowance allowance [ _from ] [ msg . sender ] -= _value ; _transfer ( _from , _to , _value ) ; return true ; }", "context": ["matchcoin", "name", "symbol", "decimals", "totalSupply", "balanceOf", "allowance"], "lines": 6, "comment": {"raw": "/**\n     * Transfer tokens from other address\n     *\n     * Send `_value` tokens to `_to` in behalf of `_from`\n     *\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */", "parsed_comment": {"parse_first_step": "     * Transfer tokens from other address     *     * Send `_value` tokens to `_to` in behalf of `_from`     *      @param _from The address of the sender      @param _to The address of the recipient      @param _value the amount to send     ", "params": {"_from": "The address of the sender", "_to": "The address of the recipient", "_value": "the amount to send"}}}}, {"content": "function approve(address _spender, uint256 _value) public\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }", "token_seq": "function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; return true ; }", "context": ["matchcoin", "name", "symbol", "decimals", "totalSupply", "balanceOf", "allowance"], "lines": 5, "comment": {"raw": "/**\n     * Set allowance for other address\n     *\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     */", "parsed_comment": {"parse_first_step": "     * Set allowance for other address     *     * Allows `_spender` to spend no more than `_value` tokens in your behalf     *      @param _spender The address authorized to spend      @param _value the max amount they can spend     ", "params": {"_spender": "The address authorized to spend", "_value": "the max amount they can spend"}}}}, {"content": "function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        public\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }", "token_seq": "function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) public returns ( bool success ) { tokenRecipient spender = tokenRecipient ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; } }", "context": ["matchcoin", "name", "symbol", "decimals", "totalSupply", "balanceOf", "allowance"], "lines": 9, "comment": {"raw": "/**\n     * Set allowance for other address and notify\n     *\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     * @param _extraData some extra information to send to the approved contract\n     */", "parsed_comment": {"parse_first_step": "     * Set allowance for other address and notify     *     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it     *      @param _spender The address authorized to spend      @param _value the max amount they can spend      @param _extraData some extra information to send to the approved contract     ", "params": {"_spender": "The address authorized to spend", "_value": "the max amount they can spend", "_extraData": "some extra information to send to the approved contract"}}}}, {"content": "function burn(uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        Burn(msg.sender, _value);\n        return true;\n    }", "token_seq": "function burn ( uint256 _value ) public returns ( bool success ) { require ( balanceOf [ msg . sender ] >= _value ) ; // Check if the sender has enough balanceOf [ msg . sender ] -= _value ; // Subtract from the sender totalSupply -= _value ; // Updates totalSupply Burn ( msg . sender , _value ) ; return true ; }", "context": ["matchcoin", "name", "symbol", "decimals", "totalSupply", "balanceOf", "allowance"], "lines": 7, "comment": {"raw": "/**\n     * Destroy tokens\n     *\n     * Remove `_value` tokens from the system irreversibly\n     *\n     * @param _value the amount of money to burn\n     */", "parsed_comment": {"parse_first_step": "     * Destroy tokens     *     * Remove `_value` tokens from the system irreversibly     *      @param _value the amount of money to burn     ", "params": {"_value": "the amount of money to burn"}}}}, {"content": "function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n        totalSupply -= _value;                              // Update totalSupply\n        Burn(_from, _value);\n        return true;\n    }", "token_seq": "function burnFrom ( address _from , uint256 _value ) public returns ( bool success ) { require ( balanceOf [ _from ] >= _value ) ; // Check if the targeted balance is enough require ( _value <= allowance [ _from ] [ msg . sender ] ) ; // Check allowance balanceOf [ _from ] -= _value ; // Subtract from the targeted balance allowance [ _from ] [ msg . sender ] -= _value ; // Subtract from the sender's allowance totalSupply -= _value ; // Update totalSupply Burn ( _from , _value ) ; return true ; }", "context": ["matchcoin", "name", "symbol", "decimals", "totalSupply", "balanceOf", "allowance"], "lines": 9, "comment": {"raw": "/**\n     * Destroy tokens from other account\n     *\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n     *\n     * @param _from the address of the sender\n     * @param _value the amount of money to burn\n     */", "parsed_comment": {"parse_first_step": "     * Destroy tokens from other account     *     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.     *      @param _from the address of the sender      @param _value the amount of money to burn     ", "params": {"_from": "the address of the sender", "_value": "the amount of money to burn"}}}}], "function_num": 8, "valid_comment_num": 0}], "contract_num": 2, "func_num": 9, "comment_num": 8, "valid_comment_num": 0}